<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <!-- スマートフォン向けの表示調整 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>パズルゲーム (スマートフォン対応・Replay付き)</title>
  <style>
    body { margin: 0; padding: 0; position: relative; }
    /* キャンバスは内部解像度 440x700（余白・パズル部分・スロット部分を確保） */
    canvas {
      border: 1px solid #000;
      display: block;
      margin: 0 auto;
      background: #fff;
      width: 100%; /* 横幅いっぱい */
      height: auto;
      touch-action: none; /* タッチ操作でのスクロールなどを無効 */
    }
    /* Replayボタン（初期は非表示） */
    #replayButton {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 20px;
      padding: 10px 20px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <!-- 内部解像度 440x700 -->
  <canvas id="gameCanvas" width="440" height="700"></canvas>
  <button id="replayButton">Replay</button>
  <script>
    (function(){
      // すべての変数はこの即時実行関数内で定義
      var canvas = document.getElementById("gameCanvas");
      var ctx = canvas.getContext("2d");

      var blockSize = 40;  // 1ブロックのピクセル数
      var margin = blockSize;  // 上下左右の余白：40px
      var boardOffsetX = margin;
      var boardOffsetY = margin;

      // ボード全体のサイズ：9x11ブロック（360x440）
      var boardCols = 9, boardRows = 11;
      var boardWidth = 360;    // 9 * 40
      var boardHeight = 440;   // 11 * 40

      // 内側エリア（パズル完成形エリア）：7x9ブロック（280x360）
      var innerCols = 7, innerRows = 9;
      var innerX = boardOffsetX + blockSize;  // 40 + 40 = 80
      var innerY = boardOffsetY + blockSize;  // 40 + 40 = 80
      var innerWidth = innerCols * blockSize;   // 280
      var innerHeight = innerRows * blockSize;    // 360

      // パズル部分とスロット部分の間に1ブロック（40px）の隙間を確保
      var trayY = boardOffsetY + boardHeight + blockSize;  // 40 + 440 + 40 = 520

      // キャンバス内部解像度は 440x700 → スロット部分の高さは 700 - 520 = 180px
      // トレイのスロットは横に3つ配置（座標は余白を考慮して設定）
      var traySlotPositions = [
        { x: boardOffsetX + 20,  y: trayY },
        { x: boardOffsetX + 140, y: trayY },
        { x: boardOffsetX + 260, y: trayY }
      ];

      // パズルピース全体を格納する配列
      var pieces = [];
      // 未配置のピースプール
      var remainingPieces = [];
      // トレイに配置されるピース（3つ固定）
      var traySlots = [ null, null, null ];

      // ドラッグ中のピースと、その元のスロット番号
      var draggingPiece = null;
      var draggingTraySlot = null;
      var dragOffsetX = 0, dragOffsetY = 0;

      // Replayボタンの設定
      var replayButton = document.getElementById("replayButton");
      replayButton.addEventListener("click", function(){
        initGame();
        replayButton.style.display = "none";
      });

      // 画像選択：imageフォルダ内の複数画像からランダムに選択
      var imageFiles = ["puzzle1.jpg", "puzzle2.jpg", "puzzle3.jpg"];
      var selectedImageFile = imageFiles[Math.floor(Math.random() * imageFiles.length)];
      var puzzleImage = new Image();
      puzzleImage.src = "image/" + selectedImageFile;
      puzzleImage.onerror = function(e) {
        console.error("画像読み込みエラー。パスを確認してください。", e);
      };

      puzzleImage.onload = function(){
        initGame();
        requestAnimationFrame(gameLoop);
      };

      // 補助関数：配列シャッフル（Fisher-Yatesアルゴリズム）
      function shuffle(array) {
        for (var i = array.length - 1; i > 0; i--) {
          var j = Math.floor(Math.random() * (i + 1));
          var temp = array[i];
          array[i] = array[j];
          array[j] = temp;
        }
      }

      // パズルピース生成
      function createPieces() {
        pieces = [];
        var gridRows = innerRows;
        var gridCols = innerCols;
        var grid = [];
        for (var r = 0; r < gridRows; r++) {
          grid[r] = [];
          for (var c = 0; c < gridCols; c++) {
            grid[r][c] = -1;
          }
        }
        var pieceId = 0;
        var cellList = [];
        for (var r = 0; r < gridRows; r++) {
          for (var c = 0; c < gridCols; c++) {
            cellList.push({ r: r, c: c });
          }
        }
        shuffle(cellList);
        cellList.forEach(function(cell) {
          var r = cell.r, c = cell.c;
          if (grid[r][c] === -1) {
            var newPiece = { id: pieceId, cells: [] };
            newPiece.cells.push({ r: r, c: c });
            grid[r][c] = pieceId;
            pieceId++;
            // 1ブロックの確率をさらに半分下げる（約0.125%）
            var rand = Math.random();
            var targetSize;
            if (rand < 0.00125) { targetSize = 1; }
            else if (rand < 0.5) { targetSize = 2; }
            else if (rand < 0.85) { targetSize = 3; }
            else { targetSize = 4; }
            while (newPiece.cells.length < targetSize) {
              var neighbors = [];
              newPiece.cells.forEach(function(cell) {
                var drs = [{ dr: -1, dc: 0 }, { dr: 1, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }];
                drs.forEach(function(d) {
                  var nr = cell.r + d.dr;
                  var nc = cell.c + d.dc;
                  if (nr >= 0 && nr < gridRows && nc >= 0 && nc < gridCols && grid[nr][nc] === -1) {
                    if (!neighbors.some(function(n) { return n.r === nr && n.c === nc; })) {
                      neighbors.push({ r: nr, c: nc });
                    }
                  }
                });
              });
              if (neighbors.length === 0) break;
              var chosen = neighbors[Math.floor(Math.random() * neighbors.length)];
              newPiece.cells.push(chosen);
              grid[chosen.r][chosen.c] = newPiece.id;
            }
            pieces.push(newPiece);
          }
        });
        // 各ピースについて、バウンディングボックスと正解位置（内側エリア上）を計算
        pieces.forEach(function(piece) {
          var minR = Infinity, minC = Infinity, maxR = -1, maxC = -1;
          piece.cells.forEach(function(cell) {
            if (cell.r < minR) minR = cell.r;
            if (cell.c < minC) minC = cell.c;
            if (cell.r > maxR) maxR = cell.r;
            if (cell.c > maxC) maxC = cell.c;
          });
          piece.minR = minR;
          piece.minC = minC;
          piece.maxR = maxR;
          piece.maxC = maxC;
          piece.width = (maxC - minC + 1) * blockSize;
          piece.height = (maxR - minR + 1) * blockSize;
          piece.targetX = innerX + (minC * blockSize);
          piece.targetY = innerY + (minR * blockSize);
          piece.placed = false;
        });
        remainingPieces = pieces.slice();
        shuffle(remainingPieces);
      }

      // ゲーム初期化
      function initGame() {
        createPieces();
        // ヒントとして、内側エリアの中心に近いピース2個を自動配置
        var centerX = innerX + innerWidth / 2;
        var centerY = innerY + innerHeight / 2;
        var sortedPieces = pieces.slice().sort(function(a, b) {
          var aCenterX = a.targetX + a.width / 2;
          var aCenterY = a.targetY + a.height / 2;
          var bCenterX = b.targetX + b.width / 2;
          var bCenterY = b.targetY + b.height / 2;
          var aDist = Math.sqrt(Math.pow(aCenterX - centerX, 2) + Math.pow(aCenterY - centerY, 2));
          var bDist = Math.sqrt(Math.pow(bCenterX - centerX, 2) + Math.pow(bCenterY - centerY, 2));
          return aDist - bDist;
        });
        for (var i = 0; i < 2; i++) {
          var hintPiece = sortedPieces[i];
          hintPiece.currentX = hintPiece.targetX;
          hintPiece.currentY = hintPiece.targetY;
          hintPiece.placed = true;
          for (var j = 0; j < remainingPieces.length; j++) {
            if (remainingPieces[j].id === hintPiece.id) {
              remainingPieces.splice(j, 1);
              break;
            }
          }
        }
        traySlots = [null, null, null];
        addPieceToTrayAtSlot(0);
        addPieceToTrayAtSlot(1);
        addPieceToTrayAtSlot(2);
      }

      // 指定スロットにピース補充
      function addPieceToTrayAtSlot(slotIndex) {
        if (remainingPieces.length > 0) {
          var piece = remainingPieces.pop();
          piece.initialX = traySlotPositions[slotIndex].x;
          piece.initialY = traySlotPositions[slotIndex].y;
          piece.currentX = piece.initialX;
          piece.currentY = piece.initialY;
          piece.traySlot = slotIndex;
          traySlots[slotIndex] = piece;
        }
      }

      // イベントの座標取得（スケール補正あり）
      function getEventPos(e) {
        var rect = canvas.getBoundingClientRect();
        var scaleX = canvas.width / rect.width;
        var scaleY = canvas.height / rect.height;
        var pos = { x: 0, y: 0 };
        if (e.touches && e.touches.length > 0) {
          pos.x = (e.touches[0].clientX - rect.left) * scaleX;
          pos.y = (e.touches[0].clientY - rect.top) * scaleY;
        } else if (e.changedTouches && e.changedTouches.length > 0) {
          pos.x = (e.changedTouches[0].clientX - rect.left) * scaleX;
          pos.y = (e.changedTouches[0].clientY - rect.top) * scaleY;
        } else {
          pos.x = (e.clientX - rect.left) * scaleX;
          pos.y = (e.clientY - rect.top) * scaleY;
        }
        return pos;
      }

      // マウス・タッチのドラッグ＆ドロップ操作
      canvas.addEventListener("mousedown", function(e) {
        var pos = getEventPos(e);
        for (var i = 0; i < traySlots.length; i++) {
          var piece = traySlots[i];
          if (piece && pointInPiece(pos.x, pos.y, piece)) {
            draggingPiece = piece;
            draggingTraySlot = i;
            dragOffsetX = pos.x - piece.currentX;
            dragOffsetY = pos.y - piece.currentY;
            traySlots[i] = null;
            break;
          }
        }
      });

      canvas.addEventListener("mousemove", function(e) {
        if (draggingPiece) {
          var pos = getEventPos(e);
          draggingPiece.currentX = pos.x - dragOffsetX;
          draggingPiece.currentY = pos.y - dragOffsetY;
        }
      });

      canvas.addEventListener("mouseup", function(e) {
        if (draggingPiece) {
          var pos = getEventPos(e);
          var tolerance = 0.8 * blockSize;
          if (Math.abs(draggingPiece.currentX - draggingPiece.targetX) < tolerance &&
              Math.abs(draggingPiece.currentY - draggingPiece.targetY) < tolerance) {
            draggingPiece.currentX = draggingPiece.targetX;
            draggingPiece.currentY = draggingPiece.targetY;
            draggingPiece.placed = true;
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            addPieceToTrayAtSlot(draggingTraySlot);
            checkGameComplete();
          } else {
            draggingPiece.currentX = traySlotPositions[draggingTraySlot].x;
            draggingPiece.currentY = traySlotPositions[draggingTraySlot].y;
            traySlots[draggingTraySlot] = draggingPiece;
          }
          draggingPiece = null;
          draggingTraySlot = null;
        }
      });

      canvas.addEventListener("mouseleave", function(e) {
        if (draggingPiece) {
          draggingPiece.currentX = traySlotPositions[draggingTraySlot].x;
          draggingPiece.currentY = traySlotPositions[draggingTraySlot].y;
          traySlots[draggingTraySlot] = draggingPiece;
          draggingPiece = null;
          draggingTraySlot = null;
        }
      });

      canvas.addEventListener("touchstart", function(e) {
        e.preventDefault();
        var pos = getEventPos(e);
        for (var i = 0; i < traySlots.length; i++) {
          var piece = traySlots[i];
          if (piece && pointInPiece(pos.x, pos.y, piece)) {
            draggingPiece = piece;
            draggingTraySlot = i;
            dragOffsetX = pos.x - piece.currentX;
            dragOffsetY = pos.y - piece.currentY;
            traySlots[i] = null;
            break;
          }
        }
      });

      canvas.addEventListener("touchmove", function(e) {
        e.preventDefault();
        if (draggingPiece) {
          var pos = getEventPos(e);
          draggingPiece.currentX = pos.x - dragOffsetX;
          draggingPiece.currentY = pos.y - dragOffsetY;
        }
      });

      canvas.addEventListener("touchend", function(e) {
        e.preventDefault();
        if (draggingPiece) {
          var pos = getEventPos(e);
          var tolerance = 0.8 * blockSize;
          if (Math.abs(draggingPiece.currentX - draggingPiece.targetX) < tolerance &&
              Math.abs(draggingPiece.currentY - draggingPiece.targetY) < tolerance) {
            draggingPiece.currentX = draggingPiece.targetX;
            draggingPiece.currentY = draggingPiece.targetY;
            draggingPiece.placed = true;
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            addPieceToTrayAtSlot(draggingTraySlot);
            checkGameComplete();
          } else {
            draggingPiece.currentX = traySlotPositions[draggingTraySlot].x;
            draggingPiece.currentY = traySlotPositions[draggingTraySlot].y;
            traySlots[draggingTraySlot] = draggingPiece;
          }
          draggingPiece = null;
          draggingTraySlot = null;
        }
      });

      function pointInPiece(x, y, piece) {
        return (x >= piece.currentX && x <= piece.currentX + piece.width &&
                y >= piece.currentY && y <= piece.currentY + piece.height);
      }

      function checkGameComplete() {
        var allPlaced = pieces.every(function(piece) {
          return piece.placed;
        });
        if (allPlaced) {
          replayButton.style.display = "block";
        }
      }

      function gameLoop() {
        draw();
        requestAnimationFrame(gameLoop);
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBoard();
        pieces.forEach(function(piece) {
          if (piece.placed) {
            drawPiece(piece);
          }
        });
        ctx.fillStyle = "#ddd";
        ctx.fillRect(0, trayY - 10, canvas.width, canvas.height - trayY + 10);
        for (var i = 0; i < traySlots.length; i++) {
          if (traySlots[i]) {
            drawPiece(traySlots[i]);
          }
        }
        if (draggingPiece) {
          drawPiece(draggingPiece);
        }
      }

      function drawBoard() {
        // 上側枠
        ctx.drawImage(puzzleImage,
          0, 0, boardWidth, blockSize,
          boardOffsetX, boardOffsetY, boardWidth, blockSize);
        // 下側枠
        ctx.drawImage(puzzleImage,
          0, boardHeight - blockSize, boardWidth, blockSize,
          boardOffsetX, boardOffsetY + boardHeight - blockSize, boardWidth, blockSize);
        // 左側枠
        ctx.drawImage(puzzleImage,
          0, blockSize, blockSize, boardHeight - 2*blockSize,
          boardOffsetX, boardOffsetY + blockSize, blockSize, boardHeight - 2*blockSize);
        // 右側枠
        ctx.drawImage(puzzleImage,
          boardWidth - blockSize, blockSize, blockSize, boardHeight - 2*blockSize,
          boardOffsetX + boardWidth - blockSize, boardOffsetY + blockSize, blockSize, boardHeight - 2*blockSize);
        // 内側エリア背景
        ctx.fillStyle = "#fff";
        ctx.fillRect(innerX, innerY, innerWidth, innerHeight);
        // 内側グリッド線
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 1;
        for (var i = 0; i <= innerCols; i++) {
          var x = innerX + i * blockSize;
          ctx.beginPath();
          ctx.moveTo(x, innerY);
          ctx.lineTo(x, innerY + innerHeight);
          ctx.stroke();
        }
        for (var j = 0; j <= innerRows; j++) {
          var y = innerY + j * blockSize;
          ctx.beginPath();
          ctx.moveTo(innerX, y);
          ctx.lineTo(innerX + innerWidth, y);
          ctx.stroke();
        }
      }

      function drawPiece(piece) {
        piece.cells.forEach(function(cell) {
          var srcX = (cell.c + 1) * blockSize;
          var srcY = (cell.r + 1) * blockSize;
          var destX = piece.currentX + (cell.c - piece.minC) * blockSize;
          var destY = piece.currentY + (cell.r - piece.minR) * blockSize;
          ctx.drawImage(puzzleImage,
            srcX, srcY, blockSize, blockSize,
            destX, destY, blockSize, blockSize);
          ctx.strokeStyle = "#000";
          ctx.strokeRect(destX, destY, blockSize, blockSize);
        });
      }
    })();
  </script>
</body>
</html>
